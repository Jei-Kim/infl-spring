# 스프링 핵심 원리 - 기본편


## chapter1 _ 객체 지향 설계와 스프링


* 스프링 등장의 배경

    - 2000년대 초반 사용하던 EJB(Enterprise Java Beans)의 단점: 코드의 복잡성, 속도 저하
    - 위의 문제점을 극복하기 위해 POJO(Plain Old Java object): '순수한 자바로 돌아가자'는 의견이 다수 등장
    - EJB 엔티티빈 기술을 대체하는 하이버네이트 등장, JPA(Java Persistence API)가 자바 표준이 됨
        - JPA == 표준 인터페이스
        - 하이버네이트, EclipseLink, etc == JPA 구현체들
    - 2002년 스프링 핵심 코드를 포함한 오픈 소스 책 출간
    - 강의는 이 배경의 시간적 흐름을 예제를 통해 살펴볼 예정


* 스프링 역사(릴리즈)

    - 2003 스프링 프레임워크 1.0 출시 - xml
    - 2006 스프링 프레임워크 2.0 출시 - xml 편의 기능 지원
    - 2009 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
    - 2013 스프링 프레임워크 4.0 출시 - 자바8
    - 2014 스프링 부트 1.0 출시
        - 기존 스프링 프레임워크의 단점은 설정에 어려움을 겪는다는 점. 이를 보완하기 위해 기본으로 설정 + 서버까지 내장되어 있는 부트 출시 -> 설정에 대한 부담감을 줄이면서 사실상 표준으로 자리 잡음


* 스프링 생태계

    - 필수
        - 스프링 프레임워크

        - 스프링 부트 
            : 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
            *** 스프링부트는 스프링프레임워크를 도와주는 도구일 뿐, 단독으로 사용할 수 없다
    
    - 선택
        - 스프링 데이터
        - 스프링 세션
        - 스프링 시큐리티
        - 스프링 Rest Docs
        - 스프링 클라우드
        - etc

    *** '스프링'단어는 문맥에 따라 해석해야 함(프레임워크, DI 컨테이너 등)
    *** 스프링은 결국 좋은 객체 프로그래밍을 지향하고, 도와주기 위해 만들어 진 것


* 좋은 객체 지향 프로그래밍이란?

    - 객체 지향 프로그래밍의 가장 중요한 키워드는 다형성(Polymorphism)
        
        * 다형성의 실세계 비유

            - 역할과 구현으로 세상을 구분
                ex. 로미오와 줄리엣 공연에서 각각의 주인공들은 어떤 배우가 맡아도 무관, 대체 가능함
            - 역할과 구현으로 구분하면 단순, 유연, 변경의 편리함이라는 이점이 있음
            - 클라이언트는 구현 대상의 역할(인터페이스)만 알면 됨
            - 클라이언트는 구현 대상의 내부 구조를 몰라도 됨
                ex. 자동차의 동작 원리를 모르더라도 사용범만 알면 됨
            - 클라이언트는 구현 대상의 내부 구조가 변경되거나 대상 자체를 변경해도 영향을 받지 않음

    * 자바 언어에서의 역할과 구현 분리
        - 다형성을 활용, 역할 == 인터페이스, 구현 == 인터페이스를 구현한 클래스, 구현 객체
        - 객체 설계 시에 역할과 구현을 !명확히! 분리
        - 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만들자
    
    * 객체의 협력이라는 관계부터 생각
        - 클라이언트는 요청, 서버는 응답하는 객체이다. 혼자 있는 객체는 없으며, 수많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가짐

    * 자바 언어의 다형성
        - 오버라이딩 기반 이헤: 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능

    * 다형성의 본질
        - 협력이라는 객체사이의 관계를 통해 이해, 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경 가능

    *** but 다형성은 인터페이스의 역할이 중요하기 때문에, 그만큼 안정적으로 잘 설계하는 것이 중요함
    
    * 스프링과 객체 지향

        - 스프링은 결국 다형성을 극대화해서 이용할 수 있게 도와주는 역할
        - 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 '역할'과 '구현'을 편리하게 다룰 수 있도록 지원
        - 레고 블럭 조립이나 위의 예시처럼 공연 배우 선택 등 구현체를 편리하게 변경 가능하다는 이점이 있음


* 좋은 객체 지향 설계의 5가지 원칙(SOLID)

 - SRP 단일 책임 원칙(Single responsibility principle)
    : 한 클래스는 하나의 책임만!

 - ***OCP 개방-폐쇄 원칙(Open/closed principle)
    : 확장에는 열려있으나, 변경에는 닫혀있어야 함
    - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 하는 경우에는 ocp원칙을 지킬 수 없다.
        -> 이러한 경우 해결법으로 스프링 DI 사용, 추후 강의에서 설명 예정

- LSP 리스코프 치환 원칙(Liskov substitution principle)
    : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
        ex. 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리 더라도 앞으로 가야함

- ISP 인터페이스 분리 원칙(Interface segregation principle)
    : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음
        -> why? 인터페이스가 명확해지고, 대체 가능성이 높아지기 때문

- ***DIP 의존관계 역전 원칙(Dependency inversion principle)
    : 구현 클래스에 의존하지 말고, 인터페이스에 의존하라 -> why? 구현체에 의존하게 되면 변 경이 아주 어려워진다.

*** 객체 지향의 핵심은 다형성 but 다형성 만으로는 쉽게 부품을 교체하듯 개발하는 것이 어려움(ocp,dip 원칙 준수 어려움) --> 해결책? 스프링


* 객체 지향 설계와 스프링

    * 스프링과 객체지향
        
        - 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
            - DI 컨테이너 제공
            - DI(Dependency Injection): 의존관계, 의존성 주입
        - 클라이언트 코드의 변경 없이 기능 확장 쉽게 부품을 교체하듯이 개발

*** 책 추천: 객체지향의 사실과 오해, 토비의 스프링3.1, 자바 ORM 표준 JPA 프로그래밍 


## chapter2 _ 스프링 핵심 원리 이해1 - 예제 만들기

## chapter3 _ 스프링 핵심 원리 이해2 - 객체 지향 원리 적용 

## chapter4 _ 스프링 컨테이너와 스프링 빈

## chapter5 _ 싱글톤 컨테이너

## chapter6 _ 컴포넌트 스캔

## chapter7 _ 의존관계 자동 주입

## chapter8 _ 빈 생명주기 콜백

## chapter9 _ 빈 스코프

## chapter10 _ 다음으로